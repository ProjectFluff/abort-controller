{"version":3,"file":"abort-controller.umd.js","sources":["../node_modules/event-target-shim/dist/event-target-shim.mjs","../src/abort-signal.ts","../src/abort-controller.ts"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    );\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };\n//# sourceMappingURL=event-target-shim.mjs.map\n","import {\n    // Event,\n    EventTarget,\n    // Type,\n    defineEventAttribute,\n} from \"event-target-shim\"\n\n// Known Limitation\n//   Use `any` because the type of `AbortSignal` in `lib.dom.d.ts` is wrong and\n//   to make assignable our `AbortSignal` into that.\n//   https://github.com/Microsoft/TSJS-lib-generator/pull/623\ntype Events = {\n    abort: any // Event & Type<\"abort\">\n}\ntype EventAttributes = {\n    onabort: any // Event & Type<\"abort\">\n}\n\n/**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */\nexport default class AbortSignal extends EventTarget<Events, EventAttributes> {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */\n    public constructor() {\n        super()\n        throw new TypeError(\"AbortSignal cannot be constructed directly\")\n    }\n\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */\n    public get aborted(): boolean {\n        const aborted = abortedFlags.get(this)\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(\n                `Expected 'this' to be an 'AbortSignal' object, but got ${\n                    this === null ? \"null\" : typeof this\n                }`,\n            )\n        }\n        return aborted\n    }\n}\ndefineEventAttribute(AbortSignal.prototype, \"abort\")\n\n/**\n * Create an AbortSignal object.\n */\nexport function createAbortSignal(): AbortSignal {\n    const signal = Object.create(AbortSignal.prototype)\n    EventTarget.call(signal)\n    abortedFlags.set(signal, false)\n    return signal\n}\n\n/**\n * Abort a given signal.\n */\nexport function abortSignal(signal: AbortSignal): void {\n    if (abortedFlags.get(signal) !== false) {\n        return\n    }\n\n    abortedFlags.set(signal, true)\n    signal.dispatchEvent<\"abort\">({ type: \"abort\" })\n}\n\n/**\n * Aborted flag for each instances.\n */\nconst abortedFlags = new WeakMap<AbortSignal, boolean>()\n\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: { enumerable: true },\n})\n\n// `toString()` should return `\"[object AbortSignal]\"`\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortSignal\",\n    })\n}\n","import AbortSignal, { abortSignal, createAbortSignal } from \"./abort-signal\"\n\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */\nclass AbortController {\n    /**\n     * Initialize this controller.\n     */\n    public constructor() {\n        signals.set(this, createAbortSignal())\n    }\n\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */\n    public get signal(): AbortSignal {\n        return getSignal(this)\n    }\n\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */\n    public abort(): void {\n        abortSignal(getSignal(this))\n    }\n}\n\n/**\n * Associated signals.\n */\nconst signals = new WeakMap<AbortController, AbortSignal>()\n\n/**\n * Get the associated signal of a given controller.\n */\nfunction getSignal(controller: AbortController): AbortSignal {\n    const signal = signals.get(controller)\n    if (signal == null) {\n        throw new TypeError(\n            `Expected 'this' to be an 'AbortController' object, but got ${\n                controller === null ? \"null\" : typeof controller\n            }`,\n        )\n    }\n    return signal\n}\n\n// Properties should be enumerable.\nObject.defineProperties(AbortController.prototype, {\n    signal: { enumerable: true },\n    abort: { enumerable: true },\n})\n\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortController\",\n    })\n}\n\nexport { AbortController, AbortSignal }\n"],"names":["pd","event","retv","privateData","get","console","assert","setCancelFlag","data","passiveListener","cancelable","canceled","preventDefault","error","Event","eventTarget","set","eventPhase","currentTarget","stopped","immediateStopped","timeStamp","Date","now","Object","defineProperty","value","enumerable","key","keys","i","length","defineRedirectDescriptor","configurable","defineCallDescriptor","apply","arguments","defineWrapper","BaseEvent","proto","CustomEvent","call","prototype","create","constructor","writable","descriptor","getOwnPropertyDescriptor","isFunc","getWrapper","wrapper","wrappers","getPrototypeOf","wrapEvent","Wrapper","isStopped","setEventPhase","setCurrentTarget","setPassiveListener","createAbortSignal","signal","AbortSignal","EventTarget","abortedFlags","abortSignal","dispatchEvent","type","getSignal","controller","signals","TypeError","WeakMap","target","composedPath","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","stopPropagation","stopImmediatePropagation","bubbles","defaultPrevented","composed","srcElement","cancelBubble","returnValue","initEvent","window","setPrototypeOf","_this","_inherits","_createClass","aborted","defineEventAttribute","defineProperties","Symbol","_typeof","toStringTag","AbortController","abort"],"mappings":";;;u4EAkCA,QAASA,EAAE,CAACC,CAAK,CAAE,CACf,GAAMC,EAAI,CAAGC,CAAW,CAACC,GAAG,CAACH,CAAK,EAMlC,MALAI,QAAO,CAACC,MAAM,CACF,IAAI,EAAZJ,CAAY,CACZ,6CAA6C,CAC7CD,CAAK,EAEFC,EAOX,QAASK,EAAa,CAACC,CAAI,CAAE,OACG,KAAI,EAA5BA,CAAI,CAACC,eAAuB,MAY5B,CAACD,CAAI,CAACP,KAAK,CAACS,UAAU,GAI1BF,CAAI,CAACG,QAAQ,IAC4B,UAAU,EAA/C,MAAOH,EAAI,CAACP,KAAK,CAACW,cAA6B,EAC/CJ,CAAI,CAACP,KAAK,CAACW,cAAc,UAhBF,WAAW,EAA9B,MAAOP,QAAuB,EACL,UAAU,EAAnC,MAAOA,QAAO,CAACQ,KAAoB,EAEnCR,OAAO,CAACQ,KAAK,CACT,oEAAoE,CACpEL,CAAI,CAACC,eAAe,GAyBpC,QAASK,EAAK,CAACC,CAAW,CAAEd,CAAK,CAAE,CAC/BE,CAAW,CAACa,GAAG,CAAC,IAAI,CAAE,CAClBD,WAAW,CAAXA,CAAW,CACXd,KAAK,CAALA,CAAK,CACLgB,UAAU,CAAE,CAAC,CACbC,aAAa,CAAEH,CAAW,CAC1BJ,QAAQ,GAAO,CACfQ,OAAO,GAAO,CACdC,gBAAgB,GAAO,CACvBX,eAAe,CAAE,IAAI,CACrBY,SAAS,CAAEpB,CAAK,CAACoB,SAAS,EAAIC,IAAI,CAACC,GAAG,GACzC,EAGDC,MAAM,CAACC,cAAc,CAAC,IAAI,CAAE,WAAW,CAAE,CAAEC,KAAK,GAAO,CAAEC,UAAU,IAAQ,EAI3E,OACUC,EAAG,CAFPC,CAAI,CAAGL,MAAM,CAACK,IAAI,CAAC5B,CAAK,EACrB6B,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGD,CAAI,CAACE,MAAM,CAAE,EAAED,CAAC,CAC1BF,CAAG,CAAGC,CAAI,CAACC,CAAC,EACZF,CAAG,GAAI,KAAI,EACbJ,MAAM,CAACC,cAAc,CAAC,IAAI,CAAEG,CAAG,CAAEI,CAAwB,CAACJ,CAAG,CAAC,EAyO1E,QAASI,EAAwB,CAACJ,CAAG,CAAE,CACnC,MAAO,CACHxB,GAAG,aAAG,CACF,MAAOJ,EAAE,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC2B,CAAG,EAC5B,CACDZ,GAAG,YAACU,CAAK,CAAE,CACP1B,CAAE,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC2B,CAAG,CAAC,CAAGF,EACzB,CACDO,YAAY,GAAM,CAClBN,UAAU,KAUlB,QAASO,EAAoB,CAACN,CAAG,CAAE,CAC/B,MAAO,CACHF,KAAK,aAAG,CACJ,GAAMzB,EAAK,CAAGD,CAAE,CAAC,IAAI,CAAC,CAACC,MACvB,MAAOA,EAAK,CAAC2B,CAAG,CAAC,CAACO,KAAK,CAAClC,CAAK,CAAEmC,SAAS,EAC3C,CACDH,YAAY,GAAM,CAClBN,UAAU,KAWlB,QAASU,EAAa,CAACC,CAAS,CAAEC,CAAK,CAAE,CAOrC,QAASC,EAAW,CAACzB,CAAW,CAAEd,CAAK,CAAE,CACrCqC,CAAS,CAACG,IAAI,CAAC,IAAI,CAAE1B,CAAW,CAAEd,CAAK,EAP3C,GAAM4B,EAAI,CAAGL,MAAM,CAACK,IAAI,CAACU,CAAK,EAC9B,GAAoB,CAAC,GAAjBV,CAAI,CAACE,MAAY,CACjB,MAAOO,EAAS,CAQpBE,CAAW,CAACE,SAAS,CAAGlB,MAAM,CAACmB,MAAM,CAACL,CAAS,CAACI,SAAS,CAAE,CACvDE,WAAW,CAAE,CAAElB,KAAK,CAAEc,CAAW,CAAEP,YAAY,GAAM,CAAEY,QAAQ,KAClE,EAGD,IAAK,GACKjB,EAAG,CADJE,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGD,CAAI,CAACE,MAAM,CAAE,EAAED,CAAC,CAEhC,GADMF,CAAG,CAAGC,CAAI,CAACC,CAAC,EACd,EAAEF,CAAG,GAAIU,EAAS,CAACI,SAAS,CAAC,CAAE,IACzBI,EAAU,CAAGtB,MAAM,CAACuB,wBAAwB,CAACR,CAAK,CAAEX,CAAG,EACvDoB,CAAM,CAA+B,YAA5B,MAAOF,EAAU,CAACpB,MACjCF,MAAM,CAACC,cAAc,CACjBe,CAAW,CAACE,SAAS,CACrBd,CAAG,CACHoB,CAAM,CACAd,CAAoB,CAACN,CAAG,CAAC,CACzBI,CAAwB,CAACJ,CAAG,CAAC,EAK/C,MAAOY,GASX,QAASS,EAAU,CAACV,CAAK,CAAE,CACvB,GAAa,IAAI,EAAbA,CAAa,EAAIA,CAAK,GAAKf,MAAM,CAACkB,SAAS,CAC3C,MAAO5B,EAAK,CAGhB,GAAIoC,EAAO,CAAGC,CAAQ,CAAC/C,GAAG,CAACmC,CAAK,EAKhC,MAJe,KAAI,EAAfW,CAAe,GACfA,CAAO,CAAGb,CAAa,CAACY,CAAU,CAACzB,MAAM,CAAC4B,cAAc,CAACb,CAAK,CAAC,CAAC,CAAEA,CAAK,EACvEY,CAAQ,CAACnC,GAAG,CAACuB,CAAK,CAAEW,CAAO,GAExBA,EAUX,QAAgBG,EAAS,CAACtC,CAAW,CAAEd,CAAK,CAAE,CAC1C,GAAMqD,EAAO,CAAGL,CAAU,CAACzB,MAAM,CAAC4B,cAAc,CAACnD,CAAK,CAAC,EACvD,MAAO,IAAIqD,EAAO,CAACvC,CAAW,CAAEd,CAAK,EASzC,QAAgBsD,EAAS,CAACtD,CAAK,CAAE,CAC7B,MAAOD,EAAE,CAACC,CAAK,CAAC,CAACmB,iBAUrB,QAAgBoC,EAAa,CAACvD,CAAK,CAAEgB,CAAU,CAAE,CAC7CjB,CAAE,CAACC,CAAK,CAAC,CAACgB,UAAU,CAAGA,EAU3B,QAAgBwC,EAAgB,CAACxD,CAAK,CAAEiB,CAAa,CAAE,CACnDlB,CAAE,CAACC,CAAK,CAAC,CAACiB,aAAa,CAAGA,EAU9B,QAAgBwC,EAAkB,CAACzD,CAAK,CAAEQ,CAAe,CAAE,CACvDT,CAAE,CAACC,CAAK,CAAC,CAACQ,eAAe,CAAGA,6sCC1ahBkD,EAAiB,GAC7B,GAAMC,EAAM,CAAGpC,MAAM,CAACmB,MAAM,CAACkB,CAAW,CAACnB,SAAS,CAAC,CAGnD,MAFAoB,EAAW,CAACrB,IAAI,CAACmB,CAAM,CAAC,CACxBG,CAAY,CAAC/C,GAAG,CAAC4C,CAAM,IAAQ,CACxBA,CACX,SAKgBI,EAAW,CAACJ,CAAmB,EACvCG,KAAAA,CAAY,CAAC3D,GAAG,CAACwD,CAAM,CAAW,GAItCG,CAAY,CAAC/C,GAAG,CAAC4C,CAAM,IAAO,CAC9BA,CAAM,CAACK,aAAa,CAAU,CAAEC,IAAI,CAAE,QAAS,CAAC,CACpD,CC/BA,QAASC,EAAS,CAACC,CAA2B,EAC1C,GAAMR,EAAM,CAAGS,CAAO,CAACjE,GAAG,CAACgE,CAAU,CAAC,CACtC,GAAc,IAAI,EAAdR,CAAc,CACd,KAAM,IAAIU,UAAS,sEAEI,IAAI,GAAnBF,CAAmB,CAAG,MAAM,GAAUA,CAC1C,GACH,CAEL,MAAOR,EACX,IF5BMzD,EAAW,CAAG,GAAIoE,SAOlBpB,CAAQ,CAAG,GAAIoB,SAkFrBzD,CAAK,CAAC4B,SAAS,CAAG,CAKd,GAAIwB,KAAI,EAAG,CACP,MAAOlE,EAAE,CAAC,IAAI,CAAC,CAACC,KAAK,CAACiE,KACzB,CAMD,GAAIM,OAAM,EAAG,CACT,MAAOxE,EAAE,CAAC,IAAI,CAAC,CAACe,YACnB,CAMD,GAAIG,cAAa,EAAG,CAChB,MAAOlB,EAAE,CAAC,IAAI,CAAC,CAACkB,cACnB,CAKDuD,YAAY,aAAG,CACX,GAAMvD,EAAa,CAAGlB,CAAE,CAAC,IAAI,CAAC,CAACkB,oBACV,KAAI,EAArBA,CAAqB,CACd,EAAE,CAEN,CAACA,CAAa,EACxB,CAMD,GAAIwD,KAAI,EAAG,CACP,MAAO,GACV,CAMD,GAAIC,gBAAe,EAAG,CAClB,MAAO,GACV,CAMD,GAAIC,UAAS,EAAG,CACZ,MAAO,GACV,CAMD,GAAIC,eAAc,EAAG,CACjB,MAAO,GACV,CAMD,GAAI5D,WAAU,EAAG,CACb,MAAOjB,EAAE,CAAC,IAAI,CAAC,CAACiB,WACnB,CAMD6D,eAAe,aAAG,CACd,GAAMtE,EAAI,CAAGR,CAAE,CAAC,IAAI,EAEpBQ,CAAI,CAACW,OAAO,IAC8B,UAAU,EAAhD,MAAOX,EAAI,CAACP,KAAK,CAAC6E,eAA8B,EAChDtE,CAAI,CAACP,KAAK,CAAC6E,eAAe,GAEjC,CAMDC,wBAAwB,aAAG,CACvB,GAAMvE,EAAI,CAAGR,CAAE,CAAC,IAAI,EAEpBQ,CAAI,CAACW,OAAO,IACZX,CAAI,CAACY,gBAAgB,IAC8B,UAAU,EAAzD,MAAOZ,EAAI,CAACP,KAAK,CAAC8E,wBAAuC,EACzDvE,CAAI,CAACP,KAAK,CAAC8E,wBAAwB,GAE1C,CAMD,GAAIC,QAAO,EAAG,CACV,QAAehF,CAAE,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC+E,QACjC,CAMD,GAAItE,WAAU,EAAG,CACb,QAAeV,CAAE,CAAC,IAAI,CAAC,CAACC,KAAK,CAACS,WACjC,CAMDE,cAAc,aAAG,CACbL,CAAa,CAACP,CAAE,CAAC,IAAI,CAAC,EACzB,CAMD,GAAIiF,iBAAgB,EAAG,CACnB,MAAOjF,EAAE,CAAC,IAAI,CAAC,CAACW,SACnB,CAMD,GAAIuE,SAAQ,EAAG,CACX,QAAelF,CAAE,CAAC,IAAI,CAAC,CAACC,KAAK,CAACiF,SACjC,CAMD,GAAI7D,UAAS,EAAG,CACZ,MAAOrB,EAAE,CAAC,IAAI,CAAC,CAACqB,UACnB,CAOD,GAAI8D,WAAU,EAAG,CACb,MAAOnF,EAAE,CAAC,IAAI,CAAC,CAACe,YACnB,CAOD,GAAIqE,aAAY,EAAG,CACf,MAAOpF,EAAE,CAAC,IAAI,CAAC,CAACmB,QACnB,CACD,GAAIiE,aAAY,CAAC1D,CAAK,CAAE,CACpB,GAAKA,CAAK,EAGV,GAAMlB,EAAI,CAAGR,CAAE,CAAC,IAAI,EAEpBQ,CAAI,CAACW,OAAO,IAC2B,SAAS,EAA5C,MAAOX,EAAI,CAACP,KAAK,CAACmF,YAA0B,GAC5C5E,CAAI,CAACP,KAAK,CAACmF,YAAY,MAE9B,CAOD,GAAIC,YAAW,EAAG,CACd,MAAO,CAACrF,CAAE,CAAC,IAAI,CAAC,CAACW,SACpB,CACD,GAAI0E,YAAW,CAAC3D,CAAK,CAAE,CACdA,CAAK,EACNnB,CAAa,CAACP,CAAE,CAAC,IAAI,CAAC,EAE7B,CASDsF,SAAS,aAAG,IAMhB9D,MAAM,CAACC,cAAc,CAACX,CAAK,CAAC4B,SAAS,CAAE,aAAa,CAAE,CAClDhB,KAAK,CAAEZ,CAAK,CACZmB,YAAY,GAAM,CAClBY,QAAQ,IACX,EAGqB,WAAW,EAA7B,MAAO0C,OAAsB,EAA4B,WAAW,EAAnC,MAAOA,OAAM,CAACzE,KAAqB,GACpEU,MAAM,CAACgE,cAAc,CAAC1E,CAAK,CAAC4B,SAAS,CAAE6C,MAAM,CAACzE,KAAK,CAAC4B,SAAS,EAG7DS,CAAQ,CAACnC,GAAG,CAACuE,MAAM,CAACzE,KAAK,CAAC4B,SAAS,CAAE5B,CAAK,8iDChTzB+C,EAAY,aAI7B,mBAEI,gBADA4B,eACM,GAAInB,UAAS,CAAC,4CAA4C,EANvCoB,OAAA,WAsB5B,MAbDC,OAAA/D,cAAAxB,IAGA,aACI,GAAMwF,EAAO,CAAG7B,CAAY,CAAC3D,GAAG,CAAC,IAAI,CAAC,CACtC,GAAuB,SAAS,EAA5B,MAAOwF,EAAqB,CAC5B,KAAM,IAAItB,UAAS,kEAEF,IAAI,GAAb,IAAa,CAAG,MAAM,GAAU,IACpC,GACH,CAEL,MAAOsB,QACV,EAtBoC9B,CAAoC,EAwB7E+B,CAAoB,CAAChC,CAAW,CAACnB,SAAS,CAAE,OAAO,CAAC,CA2BpD,GAAMqB,EAAY,CAAG,GAAIQ,QAA+B,CAGxD/C,MAAM,CAACsE,gBAAgB,CAACjC,CAAW,CAACnB,SAAS,CAAE,CAC3CkD,OAAO,CAAE,CAAEjE,UAAU,KACxB,CAAC,CAGoB,UAAU,EAA5B,MAAOoE,OAAqB,EAAkC,QAAQ,GAAtCC,EAAOD,MAAM,CAACE,WAAW,CAAa,EACtEzE,MAAM,CAACC,cAAc,CAACoC,CAAW,CAACnB,SAAS,CAAEqD,MAAM,CAACE,WAAW,CAAE,CAC7DhE,YAAY,GAAM,CAClBP,KAAK,CAAE,cACV,CAAC,IC/EAwE,EAAe,YAIjB,uBACI7B,CAAO,CAACrD,GAAG,CAAC,IAAI,CAAE2C,CAAiB,EAAE,EAexC,MAZDgC,OAAA/D,aAAAxB,IAGA,aACI,MAAO+D,EAAS,CAAC,IAAI,KAGzBvC,YAAAF,MAGO,aACHsC,CAAW,CAACG,CAAS,CAAC,IAAI,CAAC,OAC9B,IAMCE,CAAO,CAAG,GAAIE,QAAuC,IAkB3D/C,MAAM,CAACsE,gBAAgB,CAACI,CAAe,CAACxD,SAAS,CAAE,CAC/CkB,MAAM,CAAE,CAAEjC,UAAU,IAAQ,CAC5BwE,KAAK,CAAE,CAAExE,UAAU,KACtB,CAAC,CAEoB,UAAU,EAA5B,MAAOoE,OAAqB,EAAkC,QAAQ,GAAtCC,EAAOD,MAAM,CAACE,WAAW,CAAa,EACtEzE,MAAM,CAACC,cAAc,CAACyE,CAAe,CAACxD,SAAS,CAAEqD,MAAM,CAACE,WAAW,CAAE,CACjEhE,YAAY,GAAM,CAClBP,KAAK,CAAE,kBACV,CAAC"}